<!DOCTYPE html>
<html>
  <head>
    <title>Herakoi Web App</title>
    <!-- FavIcon -->
    <link rel="icon" type="image/x-icon" href="./assets/favicon.ico">
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
      /* body { margin: 0; background: black; font-family: sans-serif; display: flex; flex-direction: row; justify-content: center; align-items: flex-start; gap: 20px; padding: 20px; } */
      body {
        margin: 0;
        background: black;
        font-family: Arial, sans-serif;
      }

      #container { display: flex; flex-direction: row; gap: 20px; }
      .panel { position: relative; width: 640px; height: 480px; }
      canvas, video, img { position: absolute; top: 0; left: 0; width: 640px; height: 480px; }
      video { transform: scaleX(-1); } /* Mirror the video */
      #output_canvas { transform: scaleX(-1); } /* Mirror the output canvas */
      #upload { position: absolute; top: 10px; left: 10px; z-index: 3; background: white; padding: 6px; border-radius: 5px; }
      .controls { position: absolute; top: 500px; right: 100px; z-index: 3; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 5px; }

      header {
        background-color: #4196B4;
        color: white;
        padding: 10px;
        text-align: center;
        font-size: 24px;
        width: 100%; 
      }

      footer {
          background-color: #002A48;
          color: white;
          text-align: center;
          padding: 10px;
          position: fixed;
          bottom: 0; /* Ensure it stays at the bottom */
          width: 100%;
          display: flex; /* Enables flexbox */
          flex-direction: row;
          align-items: center;
      }

      .image-container {
          display: flex; /* Enables flexbox */
          justify-content: center; /* Centers images horizontally */
          align-items: center; /* Aligns images vertically */
          gap: 20px; /* Adds space between images */
          width: 100%; /* Full width */
          padding: 20px; /* Adds padding */
          background-color: #f4f4f4; /* Light background */
      }

      .logo {
        height: 40px;
        width: auto; 
        max-width: 100px; /* Limits width */
      }

      .sidebar {
          width: 200px;
          padding: 15px;
          background-color: #f4f4f4;
          position: fixed; /* Keeps it in place */
          left: 0;
          top: 60px; /* Below the header */
          height: calc(100vh - 80px); /* Adjust height excluding header/footer */
          border-radius: 5px;
      }
      /* Responsive Sidebar: Moves below content on small screens */
      @media (max-width: 1024px) {
          .sidebar {
              position: relative; /* Removes fixed positioning */
              width: 100%; /* Full width */
              height: auto; /* Adjust height */
              top: auto; /* Reset top positioning */
              order: 2; /* Moves below content */
          }

          .content {
              flex-direction: column; /* Stack elements vertically */
              align-items: center; /* Center content */
          }
      }
      /* Main content */ 
      .content {
        margin-left: 270px; /* Adjust to avoid overlap with sidebar */
        margin: 0; background: black; font-family: sans-serif; display: flex; flex-direction: row; justify-content: center; align-items: flex-start; gap: 20px; padding: 20px;
      }
    </style>
  </head>
  <!-- BODY -->
  <body>
    <!-- Header -->
    <header>
      Herakoi Web App
    </header>
    <!-- MAIN APP  -->
    <div class="content">
      <input type="file" id="upload" accept="image/*">
      <div id="container">
        <div class="panel">
          <canvas id="imageCanvas"></canvas>
          <canvas id="imageOverlay" style="z-index:2;"></canvas>
          <img id="inputImage" crossorigin="anonymous">
          <div class="controls">
            <label for="frequency-range">Frequency Range:</label>
            <input type="range" id="min-freq" min="100" max="500" value="200" step="10">
            <span id="min-freq-value">200</span> -
            <input type="range" id="max-freq" min="500" max="2000" value="700" step="10">
            <span id="max-freq-value">700</span> Hz
          </div>
        </div>
        <div class="panel">
          <video id="input_video" playsinline muted autoplay></video>
          <canvas id="output_canvas"></canvas>
        </div>
      </div>
    </div>

    <!-- SIDEBAR -->
    <div class="sidebar">
      <p>Welcome to HERAKOI sonification app!</p>
    </div>

    <!-- Loghi -->
    <!-- 
    <div class="image-container">
      <img src="./assets/Logo_universita_firenze.svg" class="logo">
      <img src="./assets/logo512.png" class="logo">
      <img src="./assets/4CH_logo.png" class="logo">
    </div>
    -->
    

    <!-- Footer -->
    <footer>
      <i style="text-align: center; width: 99%;"> Brought you by Michele Ginolfi, Luca di Mascolo, Alessandro Bombini</i>
    </footer>

    <!-- SCRIPT -->
    <script>
      const videoElement  = document.getElementById('input_video');
      const canvasElement = document.getElementById('output_canvas');
      const canvasCtx = canvasElement.getContext('2d');
      const imgCanvas = document.getElementById('imageCanvas');
      const imgCtx = imgCanvas.getContext('2d');
      const overlayCanvas = document.getElementById('imageOverlay');
      const overlayCtx = overlayCanvas.getContext('2d');
      const inputImage = document.getElementById('inputImage');
      const minFreqSlider = document.getElementById('min-freq');
      const maxFreqSlider = document.getElementById('max-freq');
      const minFreqValue = document.getElementById('min-freq-value');
      const maxFreqValue = document.getElementById('max-freq-value');

      let grayscaleData = null;
      let minFreq = 200;
      let maxFreq = 700;

      // Update frequency range values
      minFreqSlider.addEventListener('input', function() {
        minFreq = parseInt(this.value);
        minFreqValue.textContent = minFreq;
      });

      maxFreqSlider.addEventListener('input', function() {
        maxFreq = parseInt(this.value);
        maxFreqValue.textContent = maxFreq;
      });

      const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let oscillator = null;
      let panner = null; 
      let gainNode = null;
      
      function rgbToHsv(r, g, b) {
        // method to convert r,g,b float [0,1] range into [h,s,v] in [360, 100, 100]
        const cmax = Math.max(r, g, b);
        const cmin = Math.min(r, g, b);
        const delta = cmax - cmin;

        let h = 0;
        if (delta !== 0) {
          if (cmax === r) {
            h = 60 * (((g - b) / delta) % 6);
          } else if (cmax === g) {
            h = 60 * ((b - r) / delta + 2);
          } else {
            h = 60 * ((r - g) / delta + 4);
          }
        }
        if (h < 0) h += 360;
                
        // sat
        const s = cmax===0 ? 0 : 100*delta/cmax ;
        // value
        const v = 100*cmax;
        //console.log(h,s,v)
        return [h, s, v]
      }

      function hueToFrequency(hue,  minInput=0.0, maxInput=1.0, minOutput=200, maxOutput=700) {
        let normalized = (hue - minInput) / (maxInput - minInput); // Normalize input to range [0, 1]
        return minOutput + (maxOutput - minOutput) * normalized; // 
      }

      function brightnessToVolume(value, minInput=0.0, maxInput=1.0, minOutput=0.1, maxOutput=1.0) {
        // Method to map logarithmically the Value to Gain
        let normalized = (value - minInput) / (maxInput - minInput); // Normalize input to range [0, 1]
        let logScale = Math.log10(1 + 9 * normalized); // Logarithmic transformation
        return minOutput + (maxOutput - minOutput) * logScale; // Scale to output range
      }

      function saturationToPan(saturation, minInput=0.0, maxInput=1.0, minOutput=-1.0, maxOutput=+1.0) {
        let normalized = (saturation - minInput) / (maxInput - minInput); // Normalize input to range [0, 1]
        return minOutput + (maxOutput - minOutput) * normalized; // 
      }

      function playFrequency(freq, distance = -2, volume = 0.5) {
        if (!oscillator) {
          oscillator = audioCtx.createOscillator();   // h
          panner     = audioCtx.createStereoPanner(); // s
          gainNode   = audioCtx.createGain();         // v

          
          oscillator.type = 'sine';
          oscillator.connect(gainNode);
          //gainNode.connect(audioCtx.destination);
          gainNode.connect(panner);
          panner.connect(audioCtx.destination);
          
          oscillator.start();
        }
        
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
        panner.pan.setValueAtTime(distance, audioCtx.currentTime);
      }

      function stopFrequency() {
        if (oscillator) {
          gainNode.gain.setValueAtTime(gainNode.gain.value, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
          
          setTimeout(() => {
            oscillator.stop();
            oscillator.disconnect();
            gainNode.disconnect();
            oscillator = null;
            gainNode = null;
          }, 100);
        }
      }

      hands.onResults(results => {
        // Webcam canvas - note we're not mirroring in the drawing code since the CSS handles it
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        // Image canvas and overlay
        imgCtx.clearRect(0, 0, imgCanvas.width, imgCanvas.height);
        imgCtx.drawImage(inputImage, 0, 0, imgCanvas.width, imgCanvas.height);
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        let handDetected = false;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          handDetected = true;
          for (const handLms of results.multiHandLandmarks) {
            // Draw hand landmarks on webcam view
            drawConnectors(canvasCtx, handLms, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(canvasCtx, handLms, {color: '#FF0000', lineWidth: 1});
            
            // Draw hand landmarks on image overlay
            // For the image overlay, we need to mirror the x-coordinate to match hand movement
            const mirroredHandLms = handLms.map(landmark => {
              return {
                x: 1 - landmark.x, // Mirror the x coordinate
                y: landmark.y,
                z: landmark.z
              };
            });
            
            drawConnectors(overlayCtx, mirroredHandLms, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            drawLandmarks(overlayCtx, mirroredHandLms, {color: '#FF0000', lineWidth: 1});

            // Use index finger tip (landmark 8) for sonification
            const x = mirroredHandLms[8].x * overlayCanvas.width;
            const y = mirroredHandLms[8].y * overlayCanvas.height;
            const boxSize = 20;
            
            // Draw targeting box
            overlayCtx.strokeStyle = 'lime';
            overlayCtx.lineWidth = 2;
            overlayCtx.strokeRect(x - boxSize/2, y - boxSize/2, boxSize, boxSize);

            if (grayscaleData) {
              const pixelX = Math.floor(x);
              const pixelY = Math.floor(y);
              
              if (pixelX >= 0 && pixelX < overlayCanvas.width && pixelY >= 0 && pixelY < overlayCanvas.height) {
                const i = (pixelY * overlayCanvas.width + pixelX) * 4;
                const hue         = grayscaleData.data[i+0];
                const saturation  = grayscaleData.data[i+1];
                const brightness  = grayscaleData.data[i+2];
                // Transform h,s,v into freq, distance and volume 
                const freq     = hueToFrequency(hue/255, 0.0, 1.0, minFreq, maxFreq); //= minFreq + (hue / 255) * (maxFreq - minFreq);
                const distance = saturationToPan(saturation/255);
                const volume   = brightnessToVolume(brightness/255);// 1.0 * brightness/255.0; // Reduced volume for comfort
                // playFrequency
                playFrequency(freq, distance, volume);
                // log if wanted
                console.log(hue, saturation, brightness);
                console.log(freq, distance, volume);
                
                // Display frequency info
                overlayCtx.fillStyle = 'white';
                overlayCtx.fillRect(x + 10, y - 30, 80, 20);
                overlayCtx.fillStyle = 'black';
                overlayCtx.font = '12px sans-serif';
                overlayCtx.fillText(`${Math.round(freq)} Hz`, x + 15, y - 15);
              }
            }
          }
        }

        if (!handDetected) stopFrequency();

        canvasCtx.restore();
      });

      const camera = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
      });
      camera.start();

      document.getElementById('upload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(event) {
            inputImage.onload = function() {
              imgCtx.drawImage(inputImage, 0, 0, imgCanvas.width, imgCanvas.height);
              
              // Create grayscale version for sonification
              grayscaleData = imgCtx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
              const data = grayscaleData.data;
              
              // Convert to HSV for sonification accuracy
              for (let i = 0; i < data.length; i += 4) {
                const r = data[i + 0] / 255;
                const g = data[i + 1] / 255;
                const b = data[i + 2] / 255;
                
                const huesatval = rgbToHsv(r,g,b);
                //
                const croppedHue = huesatval[0] < 300 ? huesatval[0] : 0 ;
                const hueByte = Math.round((croppedHue   / 360) * 255);
                const satByte = Math.round((huesatval[1] / 100) * 255);
                const valByte = Math.round((huesatval[2] / 100) * 255);
                data[i + 0] = hueByte;       // Use hue for sonification
                data[i + 1] = satByte;
                data[i + 2] = valByte;
              }
            };
            inputImage.src = event.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      // Initial setup - ensure canvas sizes match
      function setupCanvasSizes() {
        const width  = 640;
        const height = 480;
        
        [canvasElement, imgCanvas, overlayCanvas].forEach(canvas => {
          canvas.width  = width;
          canvas.height = height;
        });
      }
      
      setupCanvasSizes();
      
      // Handle window resize
      window.addEventListener('resize', setupCanvasSizes);
    </script>
  </body>
</html>